[3. Message Format]
HTTP-message	=	start-line
					*(header-field CRLF)
					CRLF
					[ message-body ]

HTTP 메시지를 분석하는 일반적인 절차는 start-line을 읽고
각 헤더 필드를 빈 행까지 필드 이름으로 해시테이블로 읽은다음
분석된 데이터를 사용하여 메시지 본문이 필요한지 여부를 확인한다.

메시지 본분이 표시된경우
메시지 본문 길이와 동일한 octet의 양을 읽거나 커넥션을 닫을 때까지 스트림으로 읽는다.

수신자는 반드시 HTTP 메시지를 US-ASCII의 상위집합인 인코딩에서 octet으로 구문분석 해야한다.(MUST)

HTTP 메시지는 스트림으로 구문분석하여 증분처리하거나 다운스트림으로 전송할 수 있다.
	*증분처리 : 기존 데이터가 이미 처리되었을때
				전체 데이터 세트를 다시 처리하지 않고
				데이터 세트에 새로 추가된 데이터 파티션만 처리하는 처리방법

발신자는 start-line과 첫번째 헤더 필드 사이에 공백을 보내면 안된다.(MUST NOT)
start-liner과 첫번째 헤더 필드 사이의 공백을 수신하면 메시지를 유효하지 않은 것으로 거부
하거나 메시지를 더이상 처리하지 않고 각 공백이 지정된 줄을 소비해야한다(MUST)
	*i.e :	공백이 오는 모든 후속 줄과 함께 올바르게 형성된 헤더 필드가 수신되거나
			헤더 부분이 끝날 때까지 전체 라인을 무시한다.

[3.1 Start Line]

요청과 응답 두 유형의 메시지는 start-line(요청) status-line(응답)과
메시지 본문의 길이를 결정하기 위한 알고리즘만 다르다.
서버와 클라이언트는 다른 start-line 형식으로 구분할수 있지만
서버는 요청만, 클라이언트는 응답만을 예상하도록 구현된다.

[3.1.1 Request Line]

request-line은 method 토큰을 시작으로 공백(SP), request-target, 공백(SP), 프로토콜 버전, CRLF를 끝으로 한다.

request-line	= method SP request-target SP HTTP-version CRLF

method 토큰은 대상 리소스를 실행하기 위한 요청 메서드를 표시한다.
요청 메서드는 대 소문자를 구분한다.

세 구성요소에는 공백이 허용되지 않기 때문에
일반적으로 수신자는 공백을 분할하여 request-line을 구성 요소 부분으로 분할한다.

유효하지 않은 request-line의 수신자는 400(Bad Request) 오류 또는
301(Moved Permanently) 리다이렉트로 응답해야 하며,
request-target은 적절히 인코딩되어야 한다.(SHOULD)
수신자는 리다이렉트 없이 요청을 자동 수정하고 처리해서는 안된다.(SHOULD NOT)

request-line의 길이에 대해 미리 정의된 제한을 두지 않는다.
구현한 것보다 더 긴 메서드를 수신한 서버는 501(Not Implemented)상태코드로 응답해야 한다.(SHOULD)
request-target을 구문분석하려는 URI보다 긴 414(URI TOO Long)상태 코드로 응답해야한다.(MUST)

모든 HTTP 발신자와 수신자는 최소 8000 octet 길이의 request-line을 지원 하는것을 권장한다.(RECOMMENDED)

[3.1.2 Status Line]

